using System;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace UniEnumUtils.SourceGenerator;

[Generator]
public class UniEnumCodeGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(OnInitializationOutput);
        
#if false        
        // Enumの宣言ノードを取得
        var enumDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, ct) => node is EnumDeclarationSyntax,
                transform: static (ctx, ct) => (EnumDeclarationSyntax)ctx.Node)
            .Where(static m => m is not null).Combine(context.CompilationProvider);

        // Enumのシンボルを取得し、必要な属性が付いているかチェック
        var enumsWithAttributes = enumDeclarations.Select((data, ct) =>
            {
                var (enumDeclaration, compilation) = data;
                var model = compilation.GetSemanticModel(enumDeclaration.SyntaxTree);
                var enumSymbol = model.GetDeclaredSymbol(enumDeclaration, ct) as INamedTypeSymbol;
                if (enumSymbol is null)
                    return default;

                var hasUniEnumAttribute = enumSymbol.GetAttributes().Any(attr => attr.AttributeClass.ToDisplayString() == "UniEnumAttribute");
                var hasFlagsAttribute = enumSymbol.GetAttributes().Any(attr => attr.AttributeClass.ToDisplayString() == "System.FlagsAttribute");

                return (enumDeclaration, hasUniEnumAttribute, hasFlagsAttribute, enumSymbol);
            })
            .Where(x => x.enumSymbol is not null);
        
        context.RegisterSourceOutput(enumsWithAttributes, (spc, source) =>
        {
            var (enumDeclaration, hasUniEnumAttribute, hasFlagsAttribute, enumSymbol) = source;
        });
#endif
        
        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            "UniEnumUtils.UniEnumAttribute",
            static (node, token) => true,
            static (context, token) => context);
        
        context.RegisterSourceOutput(source, Emit);
    }

    private static void OnInitializationOutput(IncrementalGeneratorPostInitializationContext context)
    {
        var ct = context.CancellationToken;
        ct.ThrowIfCancellationRequested();
        
        context.AddSource("UniEnumAttribute.gen.cs",
            """
            namespace UniEnumUtils;

            [global::System.AttributeUsage(global::System.AttributeTargets.Enum, AllowMultiple = false, Inherited = false)]
            internal sealed class UniEnumAttribute : global::System.Attribute
            {
            }
            """);
    }

    private static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        context.CancellationToken.ThrowIfCancellationRequested();
        
        var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
        var typeNode = (TypeDeclarationSyntax)source.TargetNode;

        var hasFlagsAttribute = typeSymbol.GetAttributes().Any(v => v.AttributeClass?.Name == "FlagsAttribute");
        if (hasFlagsAttribute)
        {
            if (typeSymbol.GetMembers("HasFlagNonAlloc").Length > 0)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    DiagnosticsDescriptors.HasFlagNonAllocAlreadyDefined,
                    typeNode.GetLocation()));
                return;
            }
        }

        // グローバルネームスペースに定義されている場合は、ネームスペースを出力しない
        var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
            ? ""
            : $"namespace {typeSymbol.ContainingNamespace};";

        var fullType = EscapeForFileName(typeSymbol);
        
        var code = $$"""
                     // <auto-generated>
                     #nullable enable
                     
                     {{ns}}
                     
                     partial class {{typeSymbol.Name}}Extensions
                     {
                         public static bool HasFlagNonAlloc(this {{typeSymbol.Name}} self, {{typeSymbol.Name}} flag)
                         {
                             return (self & flag) == flag;
                         }
                     }                     
                     """;
        context.AddSource($"{fullType}Extensions.gen.cs", code);
    }
    
    private static string EscapeForFileName(INamedTypeSymbol symbol)
    {
        return symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");
    }
}

static class DiagnosticsDescriptors
{
    public static readonly DiagnosticDescriptor HasFlagNonAllocAlreadyDefined = new(
        "UE0001",
        "HasFlagNonAlloc is already defined",
        "UniEnumUtils.SourceGenerator: HasFlagNonAlloc is already defined",
        "UniEnumUtils.SourceGenerator",
        DiagnosticSeverity.Error,
        true);
} 
